/*
import { Game } from 'Game';
import NewPlant, { Plant } from './Plant';
import Coordinate from 'Coordinate';
import Name from './Name';
import { Verb } from 'Instruction';

describe('newPlant', () => {
  let plant: Plant = NewPlant(0);

  beforeEach(() => {
    plant = NewPlant(0);
  });

  it('name', () => {
    expect(plant.name).toBe('plant');
  });

  describe('tick', () => {
    let currentTick = 31;
    const northCoordinate = new Coordinate(0, 0);
    const eastCoordinate = new Coordinate(0, 0);
    const southCoordinate = new Coordinate(0, 0);
    const westCoordinate = new Coordinate(0, 0);

    let validTile: Coordinate;

    const board = {
      tileEmptyAndFertile(location: Coordinate): boolean {
        return location === validTile;
      }
    };

    const location = {
      ...new Coordinate(0, 0),
      x: 0,
      y: 0,
      north(): Coordinate { return northCoordinate },
      northEast(): Coordinate { return this },
      east(): Coordinate { return eastCoordinate },
      southEast(): Coordinate { return this },
      south(): Coordinate { return southCoordinate },
      southWest(): Coordinate { return this },
      west(): Coordinate { return westCoordinate },
      northWest(): Coordinate { return this },
    }

    describe('valid north tile', () => {
      beforeEach(() => {
        validTile = northCoordinate;
      });

      it('returns the correct instruction', () => {
        expect(plant.tick({ board, location, currentTick }).length).toBe(1);
        expect(plant.tick({ board, location, currentTick })[0].targetLocation).toBe(northCoordinate);
        expect(plant.tick({ board, location, currentTick })[0].sourceLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].executorLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].verb).toBe(Verb.reproduce);
        expect(plant.tick({ board, location, currentTick })[0].sourceName).toBe(Name.plant);
      });
    });

    describe('valid east tile', () => {
      beforeEach(() => {
        validTile = eastCoordinate;
      });

      it('returns the correct instruction', () => {
        expect(plant.tick({ board, location, currentTick }).length).toBe(1);
        expect(plant.tick({ board, location, currentTick })[0].targetLocation).toBe(eastCoordinate);
        expect(plant.tick({ board, location, currentTick })[0].sourceLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].executorLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].verb).toBe(Verb.reproduce);
        expect(plant.tick({ board, location, currentTick })[0].sourceName).toBe(Name.plant);
      });
    });

    describe('valid south tile', () => {
      beforeEach(() => {
        validTile = southCoordinate;
      });

      it('returns the correct instruction', () => {
        expect(plant.tick({ board, location, currentTick }).length).toBe(1);
        expect(plant.tick({ board, location, currentTick })[0].targetLocation).toBe(southCoordinate);
        expect(plant.tick({ board, location, currentTick })[0].sourceLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].executorLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].verb).toBe(Verb.reproduce);
        expect(plant.tick({ board, location, currentTick })[0].sourceName).toBe(Name.plant);
      });
    });

    describe('valid west tile', () => {
      beforeEach(() => {
        validTile = westCoordinate;
      });

      it('returns the correct instruction', () => {
        expect(plant.tick({ board, location, currentTick }).length).toBe(1);
        expect(plant.tick({ board, location, currentTick })[0].targetLocation).toBe(westCoordinate);
        expect(plant.tick({ board, location, currentTick })[0].sourceLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].executorLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].verb).toBe(Verb.reproduce);
        expect(plant.tick({ board, location, currentTick })[0].sourceName).toBe(Name.plant);
      });
    });

    describe('no valid tile', () => {
      beforeEach(() => {
        // Set to random coordinate to make it fail
        validTile = new Coordinate(0, 0);
      });

      it('returns the correct instruction', () => {
        expect(plant.tick({ board, location, currentTick }).length).toBe(0);
      });
    });

    describe('death', () => {
      beforeEach(() => {
        validTile = new Coordinate(0, 0);
        currentTick = 121;
      });

      it('returns the correct instruction', () => {
        expect(plant.tick({ board, location, currentTick }).length).toBe(1);
        expect(plant.tick({ board, location, currentTick })[0].executorLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].sourceLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].executorLocation).toBe(location);
        expect(plant.tick({ board, location, currentTick })[0].verb).toBe(Verb.die);
        expect(plant.tick({ board, location, currentTick })[0].sourceName).toBe(Name.plant);
      });
    });
  });
});
*/
